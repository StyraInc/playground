// generated by policy-catalog-ui-js
export default {
  "access-control": {
    "description": "",
    "id": "access-control",
    "is_new": false,
    "name": "Access Control",
    "policies": {
      "1-rbac": {
        "data": "{\n    \"user_roles\": {\n        \"alice\": [\n            \"admin\"\n        ],\n        \"bob\": [\n            \"employee\",\n            \"billing\"\n        ],\n        \"eve\": [\n            \"customer\"\n        ]\n    },\n    \"role_grants\": {\n        \"customer\": [\n            {\n                \"action\": \"read\",\n                \"type\": \"dog\"\n            },\n            {\n                \"action\": \"read\",\n                \"type\": \"cat\"\n            },\n            {\n                \"action\": \"adopt\",\n                \"type\": \"dog\"\n            },\n            {\n                \"action\": \"adopt\",\n                \"type\": \"cat\"\n            }\n        ],\n        \"employee\": [\n            {\n                \"action\": \"read\",\n                \"type\": \"dog\"\n            },\n            {\n                \"action\": \"read\",\n                \"type\": \"cat\"\n            },\n            {\n                \"action\": \"update\",\n                \"type\": \"dog\"\n            },\n            {\n                \"action\": \"update\",\n                \"type\": \"cat\"\n            }\n        ],\n        \"billing\": [\n            {\n                \"action\": \"read\",\n                \"type\": \"finance\"\n            },\n            {\n                \"action\": \"update\",\n                \"type\": \"finance\"\n            }\n        ]\n    }\n}\n",
        "description": "An example of classic Role-based Access Control (RBAC)",
        "id": "1-rbac",
        "input": "{\n    \"user\": \"alice\",\n    \"action\": \"read\",\n    \"object\": \"id123\",\n    \"type\": \"dog\"\n}\n",
        "name": "Role-based",
        "rego": "# Role-based Access Control (RBAC)\n# --------------------------------\n#\n# This example defines an RBAC model for a Pet Store API. The Pet Store API allows\n# users to look at pets, adopt them, update their stats, and so on. The policy\n# controls which users can perform actions on which resources. The policy implements\n# a classic Role-based Access Control model where users are assigned to roles and\n# roles are granted the ability to perform some action(s) on some type of resource.\n#\n# This example shows how to:\n#\n#\t* Define an RBAC model in Rego that interprets role mappings represented in JSON.\n#\t* Iterate/search across JSON data structures (e.g., role mappings)\n#\n# For more information see:\n#\n#\t* Rego comparison to other systems: https://www.openpolicyagent.org/docs/latest/comparison-to-other-systems/\n#\t* Rego Iteration: https://www.openpolicyagent.org/docs/latest/#iteration\n\npackage app.rbac\n\nimport rego.v1\n\n# By default, deny requests.\ndefault allow := false\n\n# Allow admins to do anything.\nallow if user_is_admin\n\n# Allow the action if the user is granted permission to perform the action.\nallow if {\n\t# Find grants for the user.\n\tsome grant in user_is_granted\n\n\t# Check if the grant permits the action.\n\tinput.action == grant.action\n\tinput.type == grant.type\n}\n\n# user_is_admin is true if \"admin\" is among the user's roles as per data.user_roles\nuser_is_admin if \"admin\" in data.user_roles[input.user]\n\n# user_is_granted is a set of grants for the user identified in the request.\n# The `grant` will be contained if the set `user_is_granted` for every...\nuser_is_granted contains grant if {\n\t# `role` assigned an element of the user_roles for this user...\n\tsome role in data.user_roles[input.user]\n\n\t# `grant` assigned a single grant from the grants list for 'role'...\n\tsome grant in data.role_grants[role]\n}\n"
      },
      "2-abac": {
        "data": "{\n    \"user_attributes\": {\n        \"alice\": {\n            \"tenure\": 20,\n            \"title\": \"owner\"\n        },\n        \"bob\": {\n            \"tenure\": 15,\n            \"title\": \"employee\"\n        },\n        \"eve\": {\n            \"tenure\": 5,\n            \"title\": \"employee\"\n        },\n        \"dave\": {\n            \"tenure\": 5,\n            \"title\": \"customer\"\n        }\n    },\n    \"pet_attributes\": {\n        \"dog123\": {\n            \"adopted\": true,\n            \"age\": 2,\n            \"breed\": \"terrier\",\n            \"name\": \"toto\"\n        },\n        \"dog456\": {\n            \"adopted\": false,\n            \"age\": 3,\n            \"breed\": \"german-shepherd\",\n            \"name\": \"rintintin\"\n        },\n        \"dog789\": {\n            \"adopted\": false,\n            \"age\": 2,\n            \"breed\": \"collie\",\n            \"name\": \"lassie\"\n        },\n        \"cat123\": {\n            \"adopted\": false,\n            \"age\": 1,\n            \"breed\": \"fictitious\",\n            \"name\": \"cheshire\"\n        }\n    }\n}\n",
        "description": "An example of access control based on attributes (ABAC)",
        "id": "2-abac",
        "input": "{\n    \"user\": \"bob\",\n    \"action\": \"read\",\n    \"resource\": \"dog123\"\n}\n",
        "name": "Attribute-based",
        "rego": "# Attribute-based Access Control (ABAC)\n# -------------------------------------\n#\n# This example implements ABAC for a Pet Store API. The Pet Store API allows\n# users to look at pets, adopt them, update their stats, and so on. The policy\n# controls which users can perform actions on which resources. The policy implements\n# a Attribute-based Access Control model where users, resources, and actions have\n# attributes and the policy makes decisions based on those attributes.\n#\n# This example shows how to:\n#\n#\t* Implement ABAC using Rego that leverages external data.\n#\t* Define helper rules that provide useful abstractions (e.g., `user_is_senior`).\n#\n# For more information see:\n#\n#\t* Rego comparison to other systems: https://www.openpolicyagent.org/docs/latest/comparison-to-other-systems/\n#\n# Hint: The Coverage feature lets you view the policy statements that were executed\n# when the policy was last evaluated. Try enabling Coverage and running evaluation\n# with different inputs.\n\npackage app.abac\n\nimport rego.v1\n\ndefault allow := false\n\nallow if user_is_owner\n\nallow if {\n\tuser_is_employee\n\taction_is_read\n}\n\nallow if {\n\tuser_is_employee\n\tuser_is_senior\n\taction_is_update\n}\n\nallow if {\n\tuser_is_customer\n\taction_is_read\n\tnot pet_is_adopted\n}\n\nuser_is_owner if data.user_attributes[input.user].title == \"owner\"\n\nuser_is_employee if data.user_attributes[input.user].title == \"employee\"\n\nuser_is_customer if data.user_attributes[input.user].title == \"customer\"\n\nuser_is_senior if data.user_attributes[input.user].tenure \u003e 8\n\naction_is_read if input.action == \"read\"\n\naction_is_update if input.action == \"update\"\n\npet_is_adopted if data.pet_attributes[input.resource].adopted == true\n"
      },
      "3-hierarchical-roles": {
        "data": "{\n    \"permissions\": {\n        \"admin\": [],\n        \"tech-manager\": [\n            \"create-user\",\n            \"delete-user\",\n            \"update-user\"\n        ],\n        \"tech-lead\": [\n            \"read-user\"\n        ],\n        \"developer\": [\n            \"create-project\",\n            \"delete-project\",\n            \"update-project\",\n            \"read-project\"\n        ],\n        \"devops\": [\n            \"update-deployment\",\n            \"read-deployment\"\n        ],\n        \"platform-engineer\": [\n            \"create-deployment\",\n            \"delete-deployment\"\n        ],\n        \"junior-developer\": [\n            \"read-project\",\n            \"update-project\"\n        ]\n    },\n    \"roles_graph\": {\n        \"admin\": [\n            \"tech-manager\"\n        ],\n        \"tech-manager\": [\n            \"tech-lead\"\n        ],\n        \"tech-lead\": [\n            \"developer\",\n            \"devops\",\n            \"platform-engineer\"\n        ],\n        \"developer\": [\n            \"junior-developer\"\n        ],\n        \"platform-engineer\": [\n            \"devops\"\n        ],\n        \"devops\": [],\n        \"junior-developer\": []\n    }\n}\n",
        "description": "RBAC example with hierarchical roles",
        "id": "3-hierarchical-roles",
        "input": "{\n    \"user\": \"alice\",\n    \"action\": \"delete-project\",\n    \"roles\": [\n        \"tech-lead\"\n    ]\n}\n",
        "name": "Hierarchy-based",
        "rego": "# Hierarchical Access Control with Role Inheritance\n# -------------------------------------------------\n#\n# A common method to address RBAC's problem of 'Role Explosion' is to use\n# hierarchical roles. In this example, we show how to implement a simple\n# hierarchical access control policy using a graph of related roles.\n#\n# Users make requests with one or more roles. The policy checks if the user\n# has the requested permission by traversing the role hierarchy. If the user\n# has the permission, the policy allows the request.\n#\n# Try changing the input to see how the policy behaves with these examples:\n#\n# Alice, the tech lead\n# {\n#     \"user\": \"alice\",\n#     \"action\": \"delete-project\",\n#     \"roles\": [\n#         \"tech-lead\"\n#     ]\n# }\n# Bob, the junior developer\n# {\n#     \"user\": \"bob\",\n#     \"action\": \"delete-project\",\n#     \"roles\": [\n#         \"junior-developer\"\n#     ]\n# }\n# Alice will inherit the permissions of the developer role, which has permissions\n# to delete projects. Bob, on the other hand, will not have the permission to\n# delete projects as he only has the permissions of the junior developer role\n# which does not include the delete-project permission.\n\npackage app.rbac.hierarchical\n\nimport rego.v1\n\nreachable_roles := graph.reachable(data.roles_graph, input.roles)\n\nuser_permissions contains permission if {\n\tsome role in reachable_roles\n\tsome permission in data.permissions[role]\n}\n\ndefault allow := false\n\nallow if input.action in user_permissions\n"
      }
    }
  },
  "ai": {
    "description": "",
    "id": "ai",
    "is_new": true,
    "name": "AI",
    "policies": {
      "1-model-access": {
        "description": "Use RBAC to control which models are available based on a user's groups.\n",
        "id": "1-model-access",
        "input": "{\n    \"parsed_path\": [\n        \"v1\",\n        \"chat\",\n        \"completions\"\n    ],\n    \"attributes\": {\n        \"request\": {\n            \"http\": {\n                \"headers\": {\n                    \"authorization\": \"Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwiaWF0IjoxNTE2MjM5MDIyLCJncm91cHMiOlsidGVzdGVycyJdfQ.2eoq7A3vj7KIAlrPZnHDS4VfAQIyfblkPImzTIk0PtA\"\n                },\n                \"host\": \"example-ai-app\",\n                \"method\": \"POST\",\n                \"path\": \"/v1/chat/completions\",\n                \"protocol\": \"HTTP/1.1\"\n            }\n        }\n    },\n    \"parsed_body\": {\n        \"model\": \"model-2\",\n        \"messages\": [\n            {\n                \"role\": \"user\",\n                \"content\": \"Tell me about OPA\"\n            }\n        ]\n    },\n    \"parsed_query\": {}\n}\n",
        "name": "Model Access",
        "rego": "# AI: Model Access\n# ----------------\n# Generative AI tools which expose a chat-style interface to users typically\n# need authorization rules to control access to different models. Some models\n# may be more expensive to run, or contain sensitive data and should only be\n# made available to a limited set of users.\n#\n# In this example we have a number of differed users identified by JSON Web Tokens.\n# To run the example as a different user, update line 11 in the input on the right.\n# You can change the model they're trying to access in line 21 of the input.\n#\n# Example Models\n# model-1: our most basic model available to all users\n# model-*-stage: the latest development releases, available to testers\n# model-*-internal: model supplemented with internal data, only available to data-analysts\n#\n# Example Users\n# alice: Data Analyst\n#   token: eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwiaWF0IjoxNTE2MjM5MDIyLCJncm91cHMiOlsiZGF0YS1hbmFseXN0cyJdfQ.dpT70Zz1w0hmz8N4fjHcM8EwMPuJJt7VttqDt7UpLHw\n# bob: Tester\n#   token: eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwiaWF0IjoxNTE2MjM5MDIyLCJncm91cHMiOlsidGVzdGVycyJdfQ.2eoq7A3vj7KIAlrPZnHDS4VfAQIyfblkPImzTIk0PtA\n# claire: Intern\n#   token: eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwiaWF0IjoxNTE2MjM5MDIyLCJncm91cHMiOlsiaW50ZXJucyJdfQ.7Ozsiib3SYrp-nnLNncRygwpJcJ6ZnG4lu4BMvrYJqA\n#\n# Experiment with updates to the model field and the token to see how the deny policy responds.\n\npackage ai.chat\n\nimport rego.v1\n\n# fail closed by default\ndefault allow := false\n\n# only allow when there are no denied violations in the request\nallow if count(deny) == 0\n\ndeny contains message if {\n\tevery pattern in all_accessible_models {\n\t\tnot regex.match(pattern, input.parsed_body.model)\n\t}\n\n\tmessage := sprintf(\n\t\t\"Model '%s' is not in your accessible models: %s\",\n\t\t[input.parsed_body.model, concat(\", \", all_accessible_models)],\n\t)\n}\n\ndeny contains message if {\n\tnot input.parsed_body.model\n\tmessage := \"The 'model' key must be set in requests\"\n}\n\n# model_access is a mapping of role to patterns which match models\n# that users might be accessing.\nmodel_access := {\n\t\"interns\": {\"model-1\"},\n\t\"testers\": {\"model-1\", `^model-\\d+-stage$`},\n\t\"data-analysts\": {\"model-1\", `^model-\\d+-internal$`},\n}\n\nall_accessible_models contains m if {\n\tsome group in claims.groups\n\tsome m in model_access[group]\n}\n\nclaims := io.jwt.decode(bearer_token)[1] if {\n\tio.jwt.verify_hs256(bearer_token, \"pa$$w0rd\")\n}\n\nbearer_token := t if {\n\tv := input.attributes.request.http.headers.authorization\n\tstartswith(v, \"Bearer \")\n\tt := substring(v, count(\"Bearer \"), -1)\n}\n"
      },
      "2-prompt-filtering": {
        "description": "Ensure that prompts from users are filtered before evaluation.\n",
        "id": "2-prompt-filtering",
        "input": "{\n    \"parsed_path\": [\n        \"v1\",\n        \"chat\",\n        \"completions\"\n    ],\n    \"attributes\": {\n        \"request\": {\n            \"http\": {\n                \"headers\": {\n                    \"authorization\": \"Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkphbmUgRG9lIiwiaWF0IjoxNTE2MjM5MDIyLCJncm91cHMiOlsiaW50ZXJucyJdfQ.sVhc54OVUCuqPG1XidZo9hlAp1pptWP9lTFrFtN6aTY\"\n                },\n                \"host\": \"example-ai-app\",\n                \"method\": \"POST\",\n                \"path\": \"/v1/chat/completions\",\n                \"protocol\": \"HTTP/1.1\"\n            }\n        }\n    },\n    \"parsed_body\": {\n        \"model\": \"gpt-N\",\n        \"messages\": [\n            {\n                \"role\": \"system\",\n                \"content\": \"Welcome to our generative language model system! This AI-powered tool is designed to assist you with a wide range of tasks, from generating creative content and answering questions to providing detailed explanations and helping with programming queries. Leveraging advanced machine learning techniques, this system can understand and produce human-like text based on the prompts you provide. Whether you're looking for writing inspiration, technical support, or general information, our model is here to help. Simply enter your query, and let the system generate the information or content you need. We hope you find it useful and engaging.\"\n            },\n            {\n                \"role\": \"user\",\n                \"content\": \"Please tell me about user@example.com\"\n            }\n        ]\n    },\n    \"parsed_query\": {}\n}\n",
        "name": "Prompt Filtering",
        "rego": "# AI: Prompt Filtering\n# --------------------\n# Generative AI tools which expose a chat-style interface to users typically\n# need policy to ensure usage conforms with various organizational policies.\n#\n# This example system uses and endpoint, /v1/chat/completions, to accept lists\n# of messages and generate responses. In example our request, the user has asked\n# the following question 'Please tell me about user@example.com'.\n#\n# This example shows how we can control these submissions with the following\n# policies:\n# - total tokens in messages cannot exceed 100\n# - messages from users cannot contain emails.\n#\n# Try removing the email address and making the system prompt shorter to see\n# how the deny policy output responds.\n\npackage ai.chat\n\nimport rego.v1\n\n# token limit will be enforced on all messages\ntoken_limit := 100\n\ndeny contains message if {\n\tcounts := [c |\n\t\tsome msg in input.parsed_body.messages\n\t\tc := count(regex.split(`\\s+`, msg.content))\n\t]\n\n\ttotal_tokens := sum(counts)\n\ttotal_tokens \u003e token_limit\n\n\tmessage := sprintf(\"Total token count for messages cannot exceed %d (counted %d)\", [token_limit, total_tokens])\n}\n\ndeny contains message if {\n\tcompletions\n\n\tsome i, emails in emails_in_user_messages\n\n\tmessage := sprintf(\"Messages cannot contain emails. Message %d contains: %v\", [i + 1, concat(\", \", emails)])\n}\n\nemails_in_user_messages := {i: emails} if {\n\tsome i, msg in input.parsed_body.messages\n\n\t# only run the policy on messages in the history that are from the user\n\tmsg.role == \"user\"\n\n\temails := regex.find_n(`\\S+@\\S+`, msg.content, -1)\n\n\tcount(emails) \u003e 0\n}\n\n# completions will be true when handling a matching completions API request\ncompletions if {\n\tinput.parsed_path == [\"v1\", \"chat\", \"completions\"]\n\tinput.attributes.request.http.method == \"POST\"\n}\n"
      },
      "3-file-access": {
        "description": "Ensure training file access is restricted to the appropriate groups.",
        "id": "3-file-access",
        "input": "{\n    \"parsed_path\": [\n        \"v1\",\n        \"files\"\n    ],\n    \"attributes\": {\n        \"request\": {\n            \"http\": {\n                \"headers\": {\n                    \"authorization\": \"Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkphbmUgRG9lIiwiaWF0IjoxNTE2MjM5MDIyLCJncm91cHMiOlsiaW50ZXJucyJdfQ.sVhc54OVUCuqPG1XidZo9hlAp1pptWP9lTFrFtN6aTY\"\n                },\n                \"host\": \"example-ai-app\",\n                \"method\": \"POST\",\n                \"path\": \"/v1/files\",\n                \"protocol\": \"HTTP/1.1\"\n            }\n        }\n    },\n    \"parsed_body\": {},\n    \"parsed_query\": {}\n}\n",
        "name": "File Access",
        "rego": "# AI: Files\n# ---------\n# Controlling access to API endpoints used for model customization is an important\n# policy for any AI sytem. In this example, we show how to ensure that only users\n# with in the 'trainer' group can upload files to our system.\n\n# This example system uses /v1/files to accept file uploads for training purposes\n# and we'll be guarding access to this endpoint.\n\n# Example token with trainer group for testing:\n# eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkphbmUgRG9lIiwiaWF0IjoxNTE2MjM5MDIyLCJncm91cHMiOlsidHJhaW5lciJdfQ.UaacvR8F-4Sc3ZnV7EOBP9dl2f-7Gfn8e-uymDKJYeY\n# Update the 'authorization' header in the input to 'Bearer ...' and inspect\n# the change in the output of the deny rule.\n\npackage ai.files\n\nimport rego.v1\n\ndeny contains message if {\n\tpost\n\tnot \"trainer\" in claims.groups\n\tmessage := \"Group 'trainer' is required to access this endpoint\"\n}\n\npost if {\n\tinput.parsed_path == [\"v1\", \"files\"]\n\tinput.attributes.request.http.method == \"POST\"\n}\n\nclaims := io.jwt.decode(bearer_token)[1] if {\n\tio.jwt.verify_hs256(bearer_token, \"pa$$w0rd\")\n}\n\nbearer_token := t if {\n\tv := input.attributes.request.http.headers.authorization\n\tstartswith(v, \"Bearer \")\n\tt := substring(v, count(\"Bearer \"), -1)\n}\n"
      }
    }
  },
  "all": {
    "id": "all",
    "name": "All"
  },
  "envoy": {
    "description": "",
    "id": "envoy",
    "is_new": false,
    "name": "Envoy",
    "policies": {
      "1-hello-world": {
        "description": "Allow everyone access to public APIs",
        "id": "1-hello-world",
        "input": "{\n    \"attributes\": {\n        \"destination\": {\n            \"address\": {\n                \"socketAddress\": {\n                    \"portValue\": 8000,\n                    \"address\": \"10.25.95.68\"\n                }\n            }\n        },\n        \"metadataContext\": {\n            \"filterMetadata\": {\n                \"envoy.filters.http.header_to_metadata\": {\n                    \"policy_type\": \"ingress\"\n                }\n            }\n        },\n        \"request\": {\n            \"http\": {\n                \"headers\": {\n                    \":authority\": \"example-app\",\n                    \":method\": \"GET\",\n                    \":path\": \"/\",\n                    \"accept\": \"*/*\",\n                    \"authorization\": \"Basic ZXZlOnBhc3N3b3Jk\",\n                    \"content-length\": \"0\",\n                    \"user-agent\": \"curl/7.68.0-DEV\",\n                    \"x-ext-auth-allow\": \"yes\",\n                    \"x-forwarded-proto\": \"http\",\n                    \"x-request-id\": \"1455bbb0-0623-4810-a2c6-df73ffd8863a\"\n                },\n                \"host\": \"example-app\",\n                \"id\": \"8306787481883314548\",\n                \"method\": \"GET\",\n                \"path\": \"/\",\n                \"protocol\": \"HTTP/1.1\"\n            }\n        },\n        \"source\": {\n            \"address\": {\n                \"socketAddress\": {\n                    \"portValue\": 33772,\n                    \"address\": \"10.25.95.69\"\n                }\n            }\n        }\n    },\n    \"parsed_body\": {},\n    \"parsed_path\": [],\n    \"parsed_query\": {}\n}\n",
        "name": "Hello World",
        "rego": "# Hello World\n# -----------\n#\n# This example grants public HTTP access to \"/\", full access to \"charlie\", and\n# blocks everything else. This example shows how to:\n#\n#\t* Construct a simple allowlist/deny-by-default HTTP API authorization policy.\n#\t* Refer to the data sent by Envoy in External Authorization messages.\n#\n# For more information see:\n#\n#\t* Rego Rules: https://www.openpolicyagent.org/docs/latest/#rules\n#\t* Envoy External Authorization: https://www.envoyproxy.io/docs/envoy/latest/api-v3/service/auth/v3/external_auth.proto\n\npackage envoy.http.public\n\nimport rego.v1\n\n# If neither of the rules below match, `allow` is `false`.\ndefault allow := false\n\n# `allow` is a \"rule\". The simplest kind of rules in Rego are \"if-then\" statements\n# that assign a single value to a variable. If the value is omitted, it defaults to `true`.\n# In other words, this rule is equivalent to:\n#\n#\tallow := true {\n#\t\tinput.attributes.request.http.method == \"GET\"\n#\t\tinput.attributes.request.http.path == \"/\"\n#\t}\n#\n# Since statements like `X := true { ... }` are so common, Rego lets you omit the `:= true` bit.\n#\n# This rule says (in English):\n#\n#\tallow is true if...\n#\t\tmethod is \"GET\", and...\n#\t\tpath is \"/\"\n#\n# The statements in the body of the rule are AND-ed together.\nallow if {\n\tinput.attributes.request.http.method == \"GET\"\n\tinput.attributes.request.http.path == \"/\"\n}\n\n# In Rego, logical OR is expressed by defining multiple rules with the same name.\n#\n# This rule says (in English):\n#\n#\tallow is true if authorization is \"Basic charlie\"\nallow if input.attributes.request.http.headers.authorization == \"Basic charlie\"\n"
      },
      "2-jwt": {
        "description": "Verify a JWT and use the claims for authorization",
        "id": "2-jwt",
        "input": "{\n    \"attributes\": {\n        \"destination\": {\n            \"address\": {\n                \"socketAddress\": {\n                    \"portValue\": 8000,\n                    \"address\": \"10.25.95.68\"\n                }\n            }\n        },\n        \"metadataContext\": {\n            \"filterMetadata\": {\n                \"envoy.filters.http.header_to_metadata\": {\n                    \"policy_type\": \"ingres\"\n                }\n            }\n        },\n        \"request\": {\n            \"http\": {\n                \"headers\": {\n                    \":authority\": \"example-app\",\n                    \":method\": \"POST\",\n                    \":path\": \"/pets/dogs\",\n                    \"accept\": \"*/*\",\n                    \"authorization\": \"Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJuYW1lIjoiQWxpY2lhIFNtaXRoc29uaWFuIiwicm9sZXMiOlsicmVhZGVyIiwid3JpdGVyIl0sInVzZXJuYW1lIjoiYWxpY2UifQ.md2KPJFH9OgBq-N0RonGdf5doGYRO_1miN8ugTSeTYc\",\n                    \"content-length\": \"0\",\n                    \"user-agent\": \"curl/7.68.0-DEV\",\n                    \"x-ext-auth-allow\": \"yes\",\n                    \"x-forwarded-proto\": \"http\",\n                    \"x-request-id\": \"1455bbb0-0623-4810-a2c6-df73ffd8863a\"\n                },\n                \"host\": \"example-app\",\n                \"id\": \"8306787481883314548\",\n                \"method\": \"POST\",\n                \"path\": \"/pets/dogs\",\n                \"protocol\": \"HTTP/1.1\"\n            }\n        },\n        \"source\": {\n            \"address\": {\n                \"socketAddress\": {\n                    \"portValue\": 33772,\n                    \"address\": \"10.25.95.69\"\n                }\n            }\n        }\n    },\n    \"parsed_body\": {},\n    \"parsed_path\": [\n        \"pets\",\n        \"dogs\"\n    ],\n    \"parsed_query\": {}\n}\n",
        "name": "JWT Decoding",
        "rego": "# JWT Decoding\n# ------------\n#\n# The example allows a user \"alice\" to create new dogs in a 'pet store' API.\n#\n# This example show show to:\n#\n#\t* Extract and decode a JSON Web Token (JWT).\n#\t* Verify signatures on JWT using built-in functions in Rego.\n#\t* Define helper rules that provide useful abstractions.\n#\n# For more information see:\n#\n#\t* Rego JWT decoding and verification functions:\n#     https://www.openpolicyagent.org/docs/latest/policy-reference/#token-verification\n#\n# Hint: When you click Evaluate, you see values for `allow`, `is_post`, `is_dogs`,\n# `claims` and `bearer_token` because by default the playground evaluates all of\n# the rules in the current package. You can evaluate specific rules by selecting\n# the rule name (e.g., `claims`) and clicking Evaluate Selection.\npackage envoy.http.jwt\n\nimport rego.v1\n\ndefault allow := false\n\nallow if {\n\tis_post\n\tis_dogs\n\tclaims.username == \"alice\"\n}\n\nis_post if input.attributes.request.http.method == \"POST\"\n\nis_dogs if input.attributes.request.http.path == \"/pets/dogs\"\n\nclaims := payload if {\n\t# Verify the signature on the Bearer token. In this example the secret is\n\t# hardcoded into the policy however it could also be loaded via data or\n\t# an environment variable. Environment variables can be accessed using\n\t# the `opa.runtime()` built-in function.\n\tio.jwt.verify_hs256(bearer_token, \"B41BD5F462719C6D6118E673A2389\")\n\n\t# This statement invokes the built-in function `io.jwt.decode` passing the\n\t# parsed bearer_token as a parameter. The `io.jwt.decode` function returns an\n\t# array:\n\t#\n\t#\t[header, payload, signature]\n\t#\n\t# In Rego, you can pattern match values using the `=` and `:=` operators. This\n\t# example pattern matches on the result to obtain the JWT payload.\n\t[_, payload, _] := io.jwt.decode(bearer_token)\n}\n\nbearer_token := t if {\n\t# Bearer tokens are contained inside of the HTTP Authorization header. This rule\n\t# parses the header and extracts the Bearer token value. If no Bearer token is\n\t# provided, the `bearer_token` value is undefined.\n\tv := input.attributes.request.http.headers.authorization\n\tstartswith(v, \"Bearer \")\n\tt := substring(v, count(\"Bearer \"), -1)\n}\n"
      },
      "3-roles": {
        "description": "Allow access to an API based on whether the user is an admin",
        "id": "3-roles",
        "input": "{\n    \"attributes\": {\n        \"destination\": {\n            \"address\": {\n                \"socketAddress\": {\n                    \"portValue\": 8000,\n                    \"address\": \"10.25.95.68\"\n                }\n            }\n        },\n        \"metadataContext\": {\n            \"filterMetadata\": {\n                \"envoy.filters.http.header_to_metadata\": {\n                    \"policy_type\": \"ingress\"\n                }\n            }\n        },\n        \"request\": {\n            \"http\": {\n                \"headers\": {\n                    \":authority\": \"example-app\",\n                    \":method\": \"DELETE\",\n                    \":path\": \"/pets/dogs\",\n                    \"accept\": \"*/*\",\n                    \"authorization\": \"Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJuYW1lIjoiQWxpY2lhIFNtaXRoc29uaWFuIiwicm9sZXMiOlsicmVhZGVyIiwid3JpdGVyIl0sInVzZXJuYW1lIjoiYWxpY2UifQ.md2KPJFH9OgBq-N0RonGdf5doGYRO_1miN8ugTSeTYc\",\n                    \"content-length\": \"0\",\n                    \"user-agent\": \"curl/7.68.0-DEV\",\n                    \"x-ext-auth-allow\": \"yes\",\n                    \"x-forwarded-proto\": \"http\",\n                    \"x-request-id\": \"1455bbb0-0623-4810-a2c6-df73ffd8863a\"\n                },\n                \"host\": \"example-app\",\n                \"id\": \"8306787481883314548\",\n                \"method\": \"DELETE\",\n                \"path\": \"/pets/dogs\",\n                \"protocol\": \"HTTP/1.1\"\n            }\n        },\n        \"source\": {\n            \"address\": {\n                \"socketAddress\": {\n                    \"portValue\": 33772,\n                    \"address\": \"10.25.95.69\"\n                }\n            }\n        }\n    },\n    \"parsed_body\": {},\n    \"parsed_path\": [\n        \"pets\",\n        \"dogs\"\n    ],\n    \"parsed_query\": {}\n}\n",
        "name": "Roles",
        "rego": "# Roles\n# -----\n#\n# This example grants admins the ability to do anything. This example shows\n# how to extract claims from a JSON Web Token (JWT) and perform set lookups.\n#\n# For more information see:\n#\n# * Rego Policy Reference: https://www.openpolicyagent.org/docs/latest/policy-reference/\n\npackage envoy.http.roles\n\nimport rego.v1\n\ndefault allow := false\n\n# Sets are collections of values. To test if a value `x` is a member of `set`\n# you can write `set[x]`, or `x in set`. In this case we check if the `\"username\"`\n# claim is contained in the `admin_users` set.\nallow if claims.username in admin_users\n\n# admin_users is a set of usernames.\nadmin_users := {\n\t\"alice\",\n\t\"bob\",\n}\n\n# See the 'JWT Decoding' example for an explanation.\nclaims := payload if {\n\tv := input.attributes.request.http.headers.authorization\n\tstartswith(v, \"Bearer \")\n\tt := substring(v, count(\"Bearer \"), -1)\n\tio.jwt.verify_hs256(t, \"B41BD5F462719C6D6118E673A2389\")\n\t[_, payload, _] := io.jwt.decode(t)\n}\n"
      },
      "4-urlextract": {
        "description": "Grant the user access to her own user profiles",
        "id": "4-urlextract",
        "input": "{\n    \"attributes\": {\n        \"destination\": {\n            \"address\": {\n                \"socketAddress\": {\n                    \"portValue\": 8000,\n                    \"address\": \"10.25.95.68\"\n                }\n            }\n        },\n        \"metadataContext\": {\n            \"filterMetadata\": {\n                \"envoy.filters.http.header_to_metadata\": {\n                    \"policy_type\": \"ingress\"\n                }\n            }\n        },\n        \"request\": {\n            \"http\": {\n                \"headers\": {\n                    \":authority\": \"example-app\",\n                    \":method\": \"GET\",\n                    \":path\": \"/users/profile/charlie\",\n                    \"accept\": \"*/*\",\n                    \"authorization\": \"Basic Y2hhcmxpZTpwYXNzdzByZA==\",\n                    \"content-length\": \"0\",\n                    \"user-agent\": \"curl/7.68.0-DEV\",\n                    \"x-ext-auth-allow\": \"yes\",\n                    \"x-forwarded-proto\": \"http\",\n                    \"x-request-id\": \"1455bbb0-0623-4810-a2c6-df73ffd8863a\"\n                },\n                \"host\": \"example-app\",\n                \"id\": \"8306787481883314548\",\n                \"method\": \"GET\",\n                \"path\": \"/users/profile/charlie\",\n                \"protocol\": \"HTTP/1.1\"\n            }\n        },\n        \"source\": {\n            \"address\": {\n                \"socketAddress\": {\n                    \"portValue\": 33772,\n                    \"address\": \"10.25.95.69\"\n                }\n            }\n        }\n    },\n    \"parsed_body\": {},\n    \"parsed_path\": [\n        \"users\",\n        \"profile\",\n        \"charlie\"\n    ],\n    \"parsed_query\": {}\n}\n",
        "name": "URL Extraction",
        "rego": "# URL Extraction\n# --------------\n#\n# This example allows users to read their own profiles. This example shows how to:\n#\n# \t* Perform pattern matching on JSON values in Rego.\n#\t* Use Rego built-in functions to parse base64 encoded strings.\n#\t* Use parsed inputs provided by the OPA-Istio/Envoy integration.\n#\n# For more information see:\n#\n#\t* Rego Built-in Functions: https://www.openpolicyagent.org/docs/latest/policy-reference/\n#\t* Equality: Assignment, Comparison, and Unification:\n#     https://www.openpolicyagent.org/docs/latest/policy-language/#equality-assignment-comparison-and-unification\n#\t* OPA-Istio/Envoy Integration: https://github.com/open-policy-agent/opa-envoy-plugin\n\npackage envoy.http.urlextract\n\nimport rego.v1\n\ndefault allow := false\n\nallow if {\n\tinput.attributes.request.http.method == \"GET\"\n\n\t# The `some` keyword declares local variables. This example declares a local\n\t# variable called `user_name` (used below).\n\tsome user_name\n\n\t# The `=` operator in Rego performs pattern matching/unification. OPA finds\n\t# variable assignments that satisfy this expression (as well as all of the other\n\t# expressions in the same rule.)\n\tinput.parsed_path = [\"users\", \"profile\", user_name]\n\n\t# Check if the `user_name` from path is the same as the username from the\n\t# credentials.\n\tuser_name == basic_auth.user_name\n}\n\nbasic_auth := {\"user_name\": user_name, \"password\": password} if {\n\tv := input.attributes.request.http.headers.authorization\n\tstartswith(v, \"Basic \")\n\ts := substring(v, count(\"Basic \"), -1)\n\t[user_name, password] := split(base64url.decode(s), \":\")\n}\n"
      }
    }
  },
  "kubernetes": {
    "description": "",
    "id": "kubernetes",
    "is_new": false,
    "name": "Kubernetes",
    "policies": {
      "1-hello-world": {
        "description": "Ensure every resource has a 'costcenter' label in the appropriate format",
        "id": "1-hello-world",
        "input": "{\n    \"kind\": \"AdmissionReview\",\n    \"request\": {\n        \"kind\": {\n            \"kind\": \"Pod\",\n            \"version\": \"v1\"\n        },\n        \"object\": {\n            \"metadata\": {\n                \"name\": \"myapp\",\n                \"labels\": {\n                    \"costcenter\": \"fakecode\"\n                }\n            },\n            \"spec\": {\n                \"containers\": [\n                    {\n                        \"image\": \"nginx\",\n                        \"name\": \"nginx-frontend\"\n                    },\n                    {\n                        \"image\": \"mysql\",\n                        \"name\": \"mysql-backend\"\n                    }\n                ]\n            }\n        }\n    }\n}\n",
        "name": "Hello World",
        "rego": "# Hello World\n# -----------\n#\n# This example ensures that every resource that specifies a 'costcenter' label does\n# so in the appropriate format. This example shows how to:\n#\n#\t* Define rules that generate sets of error messages (e.g., `deny` below.)\n#\t* Refer to the data sent by Kubernetes in the Admission Review request.\n#\n# For additional information, see:\n#\n#\t* Rego Rules: https://www.openpolicyagent.org/docs/latest/#rules\n#\t* Rego References: https://www.openpolicyagent.org/docs/latest/#references\n#\t* Kubernetes Admission Reviews: https://www.openpolicyagent.org/docs/latest/kubernetes-primer/#input-document\n\npackage kubernetes.validating.label\n\nimport rego.v1\n\n# `deny` generates a set of error messages. The `msg` value is added to the set\n# if the statements in the rule are true. If any of the statements are false or\n# undefined, `msg` is not included in the set.\ndeny contains msg if {\n\t# `input` is a global variable bound to the data sent to OPA by Kubernetes. In Rego,\n\t# the `.` operator selects keys from objects. If a key is missing, no error\n\t# is generated. The statement is just undefined.\n\tvalue := input.request.object.metadata.labels.costcenter\n\n\t# Check if the label value is formatted correctly.\n\tnot startswith(value, \"cccode-\")\n\n\t# Construct an error message to return to the user.\n\tmsg := sprintf(\"Costcenter code must start with `cccode-`; found `%v`\", [value])\n}\n"
      },
      "2-existence": {
        "description": "Ensure every resource has a costcenter label and that the costcenter value is in the correct format",
        "id": "2-existence",
        "input": "{\n    \"kind\": \"AdmissionReview\",\n    \"request\": {\n        \"kind\": {\n            \"kind\": \"Pod\",\n            \"version\": \"v1\"\n        },\n        \"object\": {\n            \"metadata\": {\n                \"name\": \"myapp\"\n            },\n            \"spec\": {\n                \"containers\": [\n                    {\n                        \"image\": \"nginx\",\n                        \"name\": \"nginx-frontend\"\n                    },\n                    {\n                        \"image\": \"mysql\",\n                        \"name\": \"mysql-backend\"\n                    }\n                ]\n            }\n        }\n    }\n}\n",
        "name": "Label Existence",
        "rego": "# Label Existence\n# ---------------\n#\n# This example extends Hello World to ensure that all Kubernetes resources specify\n# a 'costcenter' label and do so with the appropriate format. This example shows\n# how to:\n#\n#\t* Define policies with multiple rules that contribute to the same set (e.g., `deny` below.)\n#\t* Use the `not` keyword (a.k.a., negation) to test for undefined/missing fields.\n#\n# For additional information, see:\n#\n#\t* Rego Logical OR: https://www.openpolicyagent.org/docs/latest/#logical-or\n#\t* Rego Negation: https://www.openpolicyagent.org/docs/latest/policy-language/#negation\n\npackage kubernetes.validating.existence\n\nimport rego.v1\n\n# This definition checks if the costcenter label is not provided. Each rule definition\n# contributes to the set of error messages.\ndeny contains msg if {\n\t# The `not` keyword turns an undefined statement into a true statement. If any\n\t# of the keys are missing, this statement will be true.\n\tnot input.request.object.metadata.labels.costcenter\n\tmsg := \"Every resource must have a costcenter label\"\n}\n\n# This definition checks if the costcenter label is formatted appropriately. Each rule\n# definition contributes to the set of error messages.\ndeny contains msg if {\n\tvalue := input.request.object.metadata.labels.costcenter\n\tnot startswith(value, \"cccode-\")\n\tmsg := sprintf(\"Costcenter code must start with `cccode-`; found `%v`\", [value])\n}\n"
      },
      "3-images": {
        "description": "Ensure every image in a pod comes from a trusted registry",
        "id": "3-images",
        "input": "{\n    \"kind\": \"AdmissionReview\",\n    \"request\": {\n        \"kind\": {\n            \"kind\": \"Pod\",\n            \"version\": \"v1\"\n        },\n        \"object\": {\n            \"metadata\": {\n                \"name\": \"myapp\"\n            },\n            \"spec\": {\n                \"containers\": [\n                    {\n                        \"image\": \"hooli.com/nginx\",\n                        \"name\": \"nginx-frontend\"\n                    },\n                    {\n                        \"image\": \"mysql\",\n                        \"name\": \"mysql-backend\"\n                    }\n                ]\n            }\n        }\n    }\n}\n",
        "name": "Image Safety",
        "rego": "# Image Safety\n# ------------\n#\n# This example prevents Kubernetes Pods from using containers from untrusted image\n# registries. For simplicity, this example does NOT cover initContainers. To\n# implement this policy, the rule needs to _search_ across the array of containers\n# contained in every Pod resource. This example shows how to:\n#\n#\t* Use the 'some' keyword to declare local variables.\n#\t* Iterate/search across JSON arrays.\n#\n# For additional information see:\n#\n#\t* Rego `some` keyword: https://www.openpolicyagent.org/docs/latest/policy-language/#some-keyword\n#\t* Rego Iteration: https://www.openpolicyagent.org/docs/latest/#iteration\n\npackage kubernetes.validating.images\n\nimport rego.v1\n\ndeny contains msg if {\n\tinput.request.kind.kind == \"Pod\"\n\n\t# The `some` keyword declares local variables. This rule declares a variable\n\t# called `container`, with the value any of the input request's spec's container\n\t# objects. It then checks if the container object's `\"image\"` field does not\n\t# start with \"hooli.com/\".\n\tsome container in input.request.object.spec.containers\n\tnot startswith(container.image, \"hooli.com/\")\n\tmsg := sprintf(\"Image '%v' comes from untrusted registry\", [container.image])\n}\n"
      },
      "4-ingress": {
        "data": "{\n    \"kubernetes\": {\n        \"ingresses\": {\n            \"ecommerce\": {\n                \"foo\": {\n                    \"kind\": \"Ingress\",\n                    \"metadata\": {\n                        \"name\": \"foo\",\n                        \"namespace\": \"ecommerce\"\n                    },\n                    \"spec\": {\n                        \"rules\": [\n                            {\n                                \"host\": \"initech.com\",\n                                \"http\": {\n                                    \"paths\": [\n                                        {\n                                            \"path\": \"/finance\",\n                                            \"backend\": {\n                                                \"serviceName\": \"banking\",\n                                                \"servicePort\": 443\n                                            }\n                                        }\n                                    ]\n                                }\n                            }\n                        ]\n                    }\n                }\n            }\n        }\n    }\n}\n",
        "description": "Ensure no ingress gets created that conflicts with an existing ingress",
        "id": "4-ingress",
        "input": "{\n    \"apiVersion\": \"admission.k8s.io/v1beta1\",\n    \"kind\": \"AdmissionReview\",\n    \"request\": {\n        \"kind\": {\n            \"group\": \"extensions\",\n            \"kind\": \"Ingress\",\n            \"version\": \"v1beta1\"\n        },\n        \"operation\": \"CREATE\",\n        \"userInfo\": {\n            \"groups\": null,\n            \"username\": \"alice\"\n        },\n        \"object\": {\n            \"metadata\": {\n                \"name\": \"prod\",\n                \"namespace\": \"ecommerce\"\n            },\n            \"spec\": {\n                \"rules\": [\n                    {\n                        \"host\": \"initech.com\",\n                        \"http\": {\n                            \"paths\": [\n                                {\n                                    \"path\": \"/finance\",\n                                    \"backend\": {\n                                        \"serviceName\": \"banking\",\n                                        \"servicePort\": 443\n                                    }\n                                }\n                            ]\n                        }\n                    }\n                ]\n            }\n        }\n    }\n}\n",
        "name": "Ingress Conflicts",
        "rego": "# Ingress Conflicts\n# -----------------\n#\n# This example prevents conflicting Kubernetes Ingresses from being created. Two\n# Kubernetes Ingress resources are considered in conflict if they have the same\n# hostname. This example shows how to:\n#\n#\t* Iterate/search across JSON arrays and objects.\n#\t* Leverage external context in decision-making.\n#\t* Define helper rules that provide useful abstractions.\n#\n# For additional information see:\n#\n#\t* Rego Iteration: https://www.openpolicyagent.org/docs/latest/#iteration\n#\t* Context-aware Admission Control Policies:\n#     https://www.openpolicyagent.org/docs/latest/kubernetes-primer/#using-context-in-policies\n#\t* Caching structure with 'kube-mgmt': https://github.com/open-policy-agent/kube-mgmt#caching\n#\n# Hint: When you click Evaluate, you see values for `deny` as well as `input_ns`,\n# `input_name`, and `is_ingress` because by default the playground evaluates all\n# of the rules in the current package. You can evaluate specific rules by selecting\n# the rule name (e.g., \"deny\") and clicking Evaluate Selection.\n\npackage kubernetes.validating.ingress\n\nimport rego.v1\n\ndeny contains msg if {\n\t# This rule only applies to Kubernetes Ingress resources.\n\tis_ingress\n\n\t# Find hostnames in the Kubernetes Ingress resource being validated. In Rego,\n\t# `_` is syntactic sugar for a unique variable. Since we do not refer to this\n\t# array index anywhere else, we can use `_` instead of inventing a new variable name.\n\tsome rule in input.request.object.spec.rules\n\tinput_host := rule.host\n\n\t# Find hostnames of other Kubernetes Ingress resources that exist in the cluster.\n\t# The statement `data.kubernetes.ingress[other_ns][other_name]` iterates over all\n\t# Kubernetes Ingress resources cached inside of OPA and assigns the hostname to the\n\t# variable `other_host`.\n\tsome other_ns, other_name\n\tother_host := data.kubernetes.ingresses[other_ns][other_name].spec.rules[_].host\n\n\t# Check if this Kubernetes Ingress resource is the same as the other one that\n\t# exists in the cluster. This is important because this policy will be applied\n\t# to CREATE and UPDATE operations. Resources do not conflict with themselves.\n\t#\n\t# Hint: This statement constructs two arrays and then compares them. This is\n\t# effectively a logical OR. E.g., if `input_ns` is not equal to `other_ns` OR\n\t# `input_name` is not equal to `other_name` the statement is TRUE.\n\t[input_ns, input_name] != [other_ns, other_name]\n\n\t# Check if there is a conflict. This check could be more sophisticated if needed.\n\tinput_host == other_host\n\n\t# Construct an error message to return to the user.\n\tmsg := sprintf(\"Ingress host conflicts with ingress %v/%v\", [other_ns, other_name])\n}\n\ninput_ns := input.request.object.metadata.namespace\n\ninput_name := input.request.object.metadata.name\n\nis_ingress if {\n\tinput.request.kind.kind == \"Ingress\"\n\tinput.request.kind.group == \"extensions\"\n\tinput.request.kind.version == \"v1beta1\"\n}\n"
      }
    }
  }
}