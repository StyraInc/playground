package main

import (
	"encoding/json"
	"fmt"
	"log"
	"os"
	"path"

	"github.com/spf13/cobra"
	"gopkg.in/yaml.v2"
)

type cliConfig struct {
	Source      string
	Destination string
}

const (
	configSource      = "source"
	configDestination = "destination"
)

var (
	config cliConfig
	cmd    *cobra.Command
)

func init() {
	cmd = &cobra.Command{
		Use: path.Base(os.Args[0]) + " [OPTIONS] [arg...]",
		Run: run,
	}

	cmd.Flags().StringVar(&config.Source, configSource, "", "policy catalog source directory")
	cmd.Flags().StringVar(&config.Destination, configDestination, "", "generated policy file")
}

type Metadata struct {
	Name        string
	Description string
	IsNew       bool `yaml:"is_new"`
}

type Policy struct {
	ID       string
	Metadata Metadata
	Rego     string
	Input    string
	Data     string
}

type Catalog struct {
	ID       string
	Metadata Metadata
	Policies []Policy
}

func run(cmd *cobra.Command, args []string) {
	pcDir := config.Source

	catalogs := []Catalog{}

	catalogFiles, _ := os.ReadDir(pcDir)
	for _, c := range catalogFiles {
		if c.Name() == ".regal" {
			continue
		}

		catalog := Catalog{ID: c.Name()}
		catalogPath := fmt.Sprintf("%s/%s", pcDir, catalog.ID)

		ps, err := os.ReadDir(catalogPath)
		if err != nil {
			log.Fatalf("failed to read directory: %v", err)
		}

		for _, p := range ps {
			if p.Name() == "metadata.yaml" {
				mf, err := os.ReadFile(fmt.Sprintf("%s/metadata.yaml", catalogPath))
				if err != nil {
					log.Fatalf("failed to read file: %v", err)
				}

				err = yaml.Unmarshal([]byte(mf), &catalog.Metadata)
				if err != nil {
					log.Fatalf("failed to unmarshal yaml: %v", err)
				}

				continue
			}

			policy := Policy{ID: p.Name()}
			policyPath := fmt.Sprintf("%s/%s", catalogPath, policy.ID)

			files, err := os.ReadDir(policyPath)
			if err != nil {
				log.Fatalf("failed to read directory: %v", err)
			}

			for _, f := range files {
				// TODO: verify with test and make sure it's parsable
				switch f.Name() {
				case "metadata.yaml":
					mf, _ := os.ReadFile(fmt.Sprintf("%s/metadata.yaml", policyPath))
					yaml.Unmarshal([]byte(mf), &policy.Metadata)

				case "code.rego":
					rego, _ := os.ReadFile(fmt.Sprintf("%s/code.rego", policyPath))
					policy.Rego = string(rego)

				case "input.json":
					input, _ := os.ReadFile(fmt.Sprintf("%s/input.json", policyPath))
					policy.Input = string(input)

				case "data.json":
					data, _ := os.ReadFile(fmt.Sprintf("%s/data.json", policyPath))
					policy.Data = string(data)
				}
			}

			if policy.Metadata.Name != "" {
				catalog.Policies = append(catalog.Policies, policy)
			}
		}

		catalogs = append(catalogs, catalog)
	}

	/*
		// generated from policy-catalog-ui-js
		export default {
			all: {id: 'all', name: 'All'},
			<type>: {
				id: <type>,
				name: <type.metadata.name>,
				description: <type.metadata.description>,
				policies: {
					<policy>: {
						id: <policyId>,
						name: <metadata.name>,
						description: <metadata.description>
						rego: <code.rego>,
						input: <input.json>,
						data: <data.json>,
					}
				}
			}
		}
	*/

	policyTypes := map[string]map[string]any{
		"all": {"id": "all", "name": "All"},
	}

	for _, c := range catalogs {
		policiesForType := make(map[string]map[string]any)

		for _, p := range c.Policies {
			policy := map[string]any{
				"id":          p.ID,
				"name":        p.Metadata.Name,
				"description": p.Metadata.Description,
				"rego":        p.Rego,
			}

			if p.Input != "" {
				policy["input"] = p.Input
			}

			if p.Data != "" {
				policy["data"] = p.Data
			}

			policiesForType[p.ID] = policy
		}

		policyTypes[c.ID] = map[string]any{
			"id":          c.ID,
			"name":        c.Metadata.Name,
			"description": c.Metadata.Description,
			"is_new":      c.Metadata.IsNew,
			"policies":    policiesForType,
		}
	}

	bs, err := json.MarshalIndent(policyTypes, "", "  ")
	if err != nil {
		log.Fatalf("failed to marshal policy type json: %v", err)
	}

	generatedFilePrefix := "// generated by policy-catalog-ui-js\nexport default "
	err = os.WriteFile(config.Destination, append([]byte(generatedFilePrefix), bs...), 0644)
	if err != nil {
		log.Fatalf("failed to write file: %v", err)
	}
}

func main() {
	cmd.Execute()
}
